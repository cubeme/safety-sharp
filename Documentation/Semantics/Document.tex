% requires cm-super
% use MikTex package manager to install (might require database synchronization)
% run initexmf --mkmaps to update miktex mapfiles

\documentclass[a4paper,10pt,english]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[T1,hyphens]{url}
\usepackage[pdftex]{hyperref}
\usepackage{soul}
\usepackage{mathrsfs}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage[fleqn,leqno]{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{xspace}
\usepackage{listings}
\usepackage{cleveref}
\hypersetup{colorlinks=false, 
				linkcolor=black,
				citecolor=black,
				pdfauthor={Axel Habermaier, Johannes Leupolz},
				pdftitle={SafetySharp},
				pdfborder={0 0 0}, 
				pdfpagelayout=SinglePage,
				pdfsubject=SafetySharp}

\input{Macros}

\title{SafetySharp Semantics}
\author{Axel Habermaier, Johannes Leupolz}

\begin{document}
 
\maketitle

\section{Formal Intermediate Language}
The Formal Intermediate Language, simply called \Fil from now on, is a low-level representation of a formal model. Transformations
to model checker input languages are defined over \Fil.
\subsection{Domains}

\Fil support integers and Boolean literals as well as variables of those types. A value is either a Boolean or integer
value.
\begin{align*}
    \bool \in \Bool &:= \{ \trueExpr, \; \falseExpr \}
    \\
    \integer \in \Integer &:= \{ \ldots, -2, -1, 0, 1, 2, \ldots \}
    \\
    \var \in \Var
    \\
    \val \in \Val &:= \Bool \mid \Integer
\end{align*}

During execution, the \textit{variable environment} stores the values of all variables, provided that a value has previously been
assigned to a variable:
\begin{align*}
	\varEnvFil \in \VarEnvFil := \Var \rightarrow \liftFailure{\Val}
\end{align*}

\subsection{Expressions}

\Fil supports only side effect free expressions. Expressions consist of literal values, read operations of variables as
well as a small set of unary and binary operator applications. The \texttt{prev} operator returns the value of a global
variable at the beginning of the current step.
\begin{align*}
	\uop \in \Uop & := - \mid \neg
	\\
    \bop \in \Bop & := {} + {} \mid {} - {} \mid {} \ast {} \mid {} / {}
                       \mid {} \% {} \mid {} > {} \mid {} < {} \mid {} \geq {} 
                       \mid {} \leq {} \mid {} = {} \mid {} \neq {} \mid {} \wedge {} \mid {} \vee {}
	\\
	\expr \in \Expr & := 
		\val \mid
		\var \mid
		\prev{\var} \mid
		\unaryExpr{\uop\;}{\expr} \mid
		\binaryExpr{\;\bop\;}{\expr_1}{\expr_2}
\end{align*}

The function $\ExprSem{-} \colon \Expr \rightarrow \VarEnvFil \rightarrow \VarEnvFil \rightarrow \liftFailure{\Val}$ defines the
semantics of expressions. It is given the current variable environment and the one at the beginning of the current step.
\begin{align*}
	\ExprSem{\val} \varEnvFil \varEnvFil' &= \val \\
	\ExprSem{\var} \varEnvFil \varEnvFil' &= \varEnvFil(\var) \\
	\ExprSem{\prev{\var}} \varEnvFil \varEnvFil' &= \varEnvFil'(\var) \\
	\ExprSem{\unaryExpr{\uop\;}{\expr}} \varEnvFil \varEnvFil' &= \llbracket \uop \rrbracket (\ExprSem{\expr} \varEnvFil \varEnvFil')
	\\
	\ExprSem{\binaryExpr{\;\bop\;}{\expr_1}{\expr_2}} \varEnvFil \varEnvFil' &= \llbracket \bop \rrbracket (\ExprSem{\expr_1}
	\varEnvFil \varEnvFil', \ExprSem{\expr_2} \varEnvFil \varEnvFil')
\end{align*}

\subsection{Statements}

\Fil is an imperative, sequential, and nondeterministic language supporting skip statements, variable assignments, sequential
compositions and guarded commands.
\begin{align*}
	\stmFil \in \StmFil & :=
		\skipStm \mid 
		\assignVarStm{\var}{\expr} \mid 
		\seqStm{\stmFil_1}{\stmFil_2} \mid
		\guardedStm{\toList{(\guardedClause{\expr}{\stmFil})}}
\end{align*}

The nondeterministic rule system $\stmArrowFil$ defines the natural (big-step) semantics of statements.
\begin{align*}
	\mathit{Configurations} \colon & \;\configurationFil{\stmFil, \varEnvFil, \varEnvFil'} \in \StmFil \times \VarEnvFil \times
	\VarEnvFil, \; \varEnvFil \in \VarEnvFil
	\\
	\mathit{Transitions} \colon & \;\configurationFil{\stmFil, \varEnvFil, \varEnvFil'} \stmArrowFil \varEnvFil''
\end{align*}

The skip statement has no effect on the variable environment and is therefore simply discarded.
\begin{equation*}
	\tag{skip}
	\configurationFil{\skipStm, \varEnvFil, \varEnvFil'}
		\stmArrowFil
	\varEnvFil
\end{equation*}

Assignments to a variable update the variable environment accordingly, replacing the variable's current value with the value
obtained from the evaluation of the assigned expression.
\begin{equation*}
	\tag{assign}
	\configurationFil{\assignVarStm{\var}{\expr}, \varEnvFil, \varEnvFil'}
		\stmArrowFil
	\varEnvFil[\var \mapsto \ExprSem{\expr} \varEnvFil \varEnvFil']
\end{equation*}

Sequential composition executes two statements sequentially, carrying along the modified variable environment.
\begin{equation*}
	\tag{seq}
	\dfrac
	{
		\configurationFil{\stmFil_1, \varEnvFil, \varEnvFil'}
			\stmArrowFil
		\varEnvFil_1
		\qquad
		\configurationFil{\stmFil_2, \varEnvFil_1, \varEnvFil'}
			\stmArrowFil
		\varEnvFil_2
	}
	{
		\configurationFil{\seqStm{\stmFil_1}{\stmFil_2}, \varEnvFil, \varEnvFil'}
			\stmArrowFil
		\varEnvFil_2
	}
\end{equation*}

Guarded commands nondeterministically choose and execute a statement whose corresponding guard evaluates to true. If no guard
evaluates to true, the rule cannot be applied and hence the program is ``stuck''.
\begin{equation*}
	\tag{cmd}
	\dfrac
	{
		\configurationFil{\stmFil_i, \varEnvFil, \varEnvFil'}
			\stmArrowFil
		\varEnvFil''
	}
	{
		\configurationFil{\guardedClause{\expr_1}{\stmFil_1} \; \ldots \; \guardedClause{\expr_n}{\stmFil_n}, \varEnvFil, \varEnvFil'}
			\stmArrowFil
		\varEnvFil''
	}
	\qquad \text{if} \quad \ExprSem{e_i} \varEnvFil \varEnvFil' = \true
\end{equation*}

A denotational definition of the statement semantics might be able to better highlight the nondeterministic nature of guarded
commands. Therefore, let the semantic relation $\StmSem{-} \colon \StmFil \rightarrow \ToSet{(\VarEnvFil \times \VarEnvFil \times
\VarEnvFil)}$ define the denotational semantics of statements as follows:
\begin{align*}
	\StmSem{\skipStm} &= \{ (\varEnvFil, \varEnvFil', \varEnvFil) \mid \varEnvFil, \varEnvFil' \in \VarEnvFil \}
	\\
	\StmSem{\assignVarStm{\var}{\expr}} &= \{ (\varEnvFil, \varEnvFil', \varEnvFil[\var \mapsto \ExprSem{\expr} \varEnvFil
	\varEnvFil']) \mid \varEnvFil, \varEnvFil' \in \VarEnvFil \}
	\\
	\StmSem{\seqStm{\stmFil_1}{\stmFil_2}} &= \StmSem{\stmFil_2} \circ \StmSem{\stmFil_1}
	\\
	\StmSem{\guardedClause{\expr_1}{\stmFil_1} \ldots \guardedClause{\expr_n}{\stmFil_n}} &= 
		\bigcup\nolimits_{i = 1}^n \,
		\{ (\varEnvFil, \varEnvFil', \varEnvFil'') \in \StmSem{\stmFil_i} \mid \ExprSem{e_i} \varEnvFil \varEnvFil' = \true \}
\end{align*}

Alternatively, we could define the semantic relation $\StmSem{-}$ by reusing rule system $\stmArrowFil$:
\begin{equation*}
	\StmSem{\stmFil} := \{ (\varEnvFil, \varEnvFil', \varEnvFil'') \in \VarEnvFil \times \VarEnvFil \times \VarEnvFil \mid
	\configurationFil{\stmFil, \varEnvFil, \varEnvFil'} \stmArrowFil \varEnvFil'' \}
\end{equation*}

\subsection{Semantics of \Fil Programs}

\Fil programs have a set of global and local variables. A \Fil program is executed in a series of steps, with each step executing
the same statement. There are global variables that are initialized once and whose values are preserved between
different steps of the program. Additionally, there are step-local variables whose values are not preserved between different
program steps.
\begin{equation*}
	\prog \in \Prog := \ToSet{\Var} \times \ToSet{\Var} \times (\Var \rightarrow \ToSet{\Val}) \times \StmFil
\end{equation*}

The first set of variables represents the global variables defined by a program, whereas the second set describes the step-local
ones. The function is used to determine the initial values of all (global) variables; there might be multiple initial
values for each variable. The statement of a program is executed once during each step.

\begin{samepage}
	The semantics of a \Fil program is a set of \textit{traces}, with each trace being an infinite sequence $\varEnvFil_0 \,
	\varEnvFil_1 \, \varEnvFil_2 \ldots$ of variable environments. We have $\{ \varEnvFil_0 \, \varEnvFil_1 \, \varEnvFil_2 \ldots \}
	\in \mathit{traces}(\prog \triangleright \toSet{\var}_g, \toSet{\var}_l, \mathit{init}, \stmFil)$ if
	\begin{itemize}
		\item $\forall \var \in \toSet{\var}_g \colon \varEnvFil_0(\var) \in \mathit{init}(\var)$
		\item $\forall \var \in \Var \setminus \toSet{\var}_g \colon \varEnvFil_0(\var) = \missing$
		\item $\forall i \in \mathbb{N}_0 \colon \configurationFil{\stmFil, \varEnvFil_i, \varEnvFil_i} \stmArrowFil
		\varEnvFil_{i+1}' \wedge \varEnvFil_{i+1} = \varEnvFil_{i + 1}'[\toSet{\var}_l \mapsto \missing]$
	\end{itemize}
\end{samepage}

\subsection{Well-Formedness of \Fil Programs}
\begin{itemize}
	\item All expressions and statements are typed correctly.
	\item \st{All variables are written to before they are assigned (definitely assigned, see also discussion of well-formedness of
	formal models).} Now guaranteed as all variables are default-initialized.
\end{itemize}

\section{Conventions}
Throughout the remainder of this report, we use the following conventions in all formal definitions wherever appropriate:

\header{Optional Elements and Failure Elements}
	We use $\missing$ and $\failure$ to denote the missing element and the failure element respectively. For some domain $A$, it is
	always true that $\missing \notin A$ and $\failure \notin A$. We define the liftings $\liftMissing{A} := A \cup
	\missing$, $\liftFailure{A} := A \cup \failure$, and $\liftMissingFailure{A} := A \cup \varepsilon \cup	\bot$.
	For some $a \in A$, we know that $a \neq \missing$ and $a \neq \failure$, whereas for $\liftMissing{a} \in
	\liftMissing{A}$, we only know that $\liftMissing{a} \neq \failure$, but $\liftMissing{a}$ might be $\missing$ or
	any element of $A$. When we write $a \in \liftMissing{A}$ or $a = f(a')$ for some function $f \colon A \rightarrow
	\liftMissing{A}$, $a$ cannot be $\missing$, so the selection or assignment is only possible if the selected or
	returned value is not $\missing$. For example, this allows us to shorten some side conditions in function definitions with case
	distinctions. The following two definitions of function $g \colon A \rightarrow \liftFailure{A}$ illustrate the usage of this
	convention.
	With function $f$ defined as above, the following two definitions of $g$ are equivalent:
	\begin{align*}
		g(a') = \begin{cases}
			a & \text{if } \quad a = f(a') \\
			\bot & \text{if } \quad \missing = f(a')
		\end{cases} 
		&&&
		g(a') = \begin{cases}
			\liftMissing{a} & \text{if } \quad \liftMissing{a} = f(a') \wedge \liftMissing{a} \neq \missing	\\
			\bot & \text{if } \quad \missing = f(a')
		\end{cases}
	\end{align*}

\header{Functions}
	Oftentimes, the codomain of some function includes the failure element. Usually the definitions of those functions contain case distinctions.
	Whenever we do not specify all cases for such a function, the remaining cases are implicitly assumed to return $\failure$.
	Alternatively, we use the word ``otherwise'' to denote a side condition that is true if the side conditions of all other cases are not true. We do not use partial functions.

	It is sometimes necessary to change the value a function returns for a specific input. We establish the notation $f[a \mapsto b]$
	for some function $f \colon A \rightarrow B$ that serves this purpose and is defined as follows:
	\begin{equation*}
	f[a \mapsto b](a') = \begin{cases}
		b & \text{if } \quad a' = a \\
		f(a') & \text{otherwise}
	\end{cases}
	\end{equation*}

	For convenience, we use the following notations to update several values at the same time: 
	$f[a_1 \; a_2 \mapsto b] = f[a_1 \mapsto b][a_2 \mapsto b]$, $f[a_1 \; a_2 \mapsto b_1 \; b_2] = f[a_1 \mapsto b_1][a_2 \mapsto b_2]$, and $\_$ represents all
	input values, such that $f[ \_ \mapsto b](a)$ returns $b$ for all input values $a$.	This is only well-defined if all updated input values are
	mutually distinct.

\header{Metavariables}
	Words starting with a capital letter denote a semantic domain. For instance, the set of two-dimensional vectors might be defined as 
	$\mathit{Vector2} = \mathbb{R} \times \mathbb{R}$. To denote a single element of a domain, we use metavariables that are identical to the domain's
	name starting with a lower-case letter; in this example, $\mathit{vector2}$. 
	The default metavariable for a domain can be overridden by explicitly specifying the metavariable 
	when defining the domain, such as $v \in \mathit{Vector2} = \mathbb{R} \times \mathbb{R}$. In this case, $v$ denotes an element of domain $\mathit{Vector2}$.
	We also use metavariables in variously decorated forms such as $v'$, $v''$, $v_0$, $v_1$, and so on. 
	We adorn a domain's metavariable with an arrow at the top to denote a list of elements of the domain, for example
	$\toList{v} \in \ToList{\mathit{Vector2}}$.
 
\header{Handling of Tuples}
	Most of the semantic domains we deal with in the following chapters consist of several subdomains. 
	Let $X = A \times B \times C \times D \times \ToList{E}$ be a domain and $x \in X$ be
	an element of that domain. To get the projection of $x$ to one of its subdomains, we subscript $x$ with the metavariable of the
	domain we want to project to. For instance, to get $x$'s projection to domain $D$, we write $x_d$. We use the same convention if the projected subdomain is
	a list, so $x_{\toList{e}}$ projects $x$ to the element in $\ToList{E}$.
	
	We often have a complex tuple type instance like $(a, b, c, d, \toList{e}) \in X$, but in a rule or
	function we actually only need a few of the variables. For example, suppose we only need to use $c$ and $\toList{e}$ in a rule. In that case,
	we write $x \triangleright c, \toList{e}$.
	This way, we can reference the entire tuple with $x$ and do not need any projections to access $x$'s subdomains. When using this projection syntax, we list the
	metavariables of the subdomains in the order they were specified in the definition of $X$. If this notational convention causes any ambiguities, we either
	resort to the standard tuple notation or list all subdomains in our projection notation. We use a notation similar to the
	projection syntax to update only some of a tuple's values: If $x \triangleright a, b, c, d, \toList{e}$, we write $x' = x
	\triangleleft a', \toList{e'}$ as an alternative to $x' = (a', b, c, d, \toList{e'})$.  

\section{Safety Component Model}
We're now going to define the syntactic and semantic
domains of the Safety Component Metamodel. The basic structure of a Safety Component Model (\Scm) is shown
in~\cref{FormalModelOverview}.
The models can be parsed in one step, as the models follow a declare-before-use paradigm.

\begin{lstlisting}[tabsize=4,basicstyle=\footnotesize\ttfamily,label=FormalModelOverview,caption={Basic Structure of a
Safety Component Model},escapeinside={(*}{*)}]
component C
{
	// subcomponents
	component D
	{
		// fields
		b : bool = false; // deterministic initial value
			 		
		// required port
		Y();
		
		// provided port
		X(in p1 : int, inout r1 : bool, in p2 : int, inout r2 : bool)
		{
			Y();
			r1 = false;
			r2 = b;
		}
	}
	
	// fields
	x : int = 1, 2, 3; // nondeterministic initial value
	b : bool = true, false;
	stuckValue : bool = b; // initial value depends on initial value of other field
	
	// Faults
	fault Stuck
	{
		step
		{
			choice
			{
				true => { Stuck = true; stuckValue = b; } // accesses to fields 
				true => { Stuck = false; }                // of declaring component
			}
		}
	}
			
	// required ports
	M(in p1 : int, inout r1 : bool, in p2 : int, inout r2 : bool);
		
	// provided ports; overloaded on fault expressions
	X(in p1 : int, inout r1 : bool, in p2 : int, inout r2 : bool)
	{
		int x;
		int y;
		
		r1 = p1 > 1;
		r2 = p2 > x && b;
	}
	
	[Stuck] // or more complex fault expression like [F1 && F2 && !F3 && !F4]
	X(in p1 : int, inout r1 : bool, in p2 : int, inout r2 : bool)
	{
		r1 = stuckValue;
		r2 = stuckValue;
	}
	
	Y()
	{
	}
		
	// bindings
	C.M = delayed D.X;  // ok as D.X has no side-effects
	D.Y = instantly C.Y;
	
	// step behavior; overloaded on fault expressions
	step
	{
		bool l1;
		bool l2;
				
		M(in x, inout l1, in x - 1, inout l2);
		Y();
		
		choice
		{
			l1 => { x = x - 1; }
			l2 => { b = true; }
		}
		
		D();
		Stuck();
		F();
	}
	
	[Stuck]
	step
	{
		bool l1;
		bool l2;
		M(in x, inout l1; in x - 1, inout l2);
	}
}
\end{lstlisting}

\subsection{Domains of Safety Component Models}
We assume a domain of \textit{variables} that represent provided port input and output parameters as well as local variables with
a default initial value. \textit{Fields}, on the other hand, represent component-global variables with one or more initial values.
\textit{Required} and \textit{provided ports} allow different components to communicate with each other. A component can
optionally be affected by one or more \textit{faults}.
\begin{align*}
	\var &\in \Var \\
	\field &\in \Field \\
	\reqPort &\in \ReqPort \\
	\provPort &\in \ProvPort \\
	\fault &\in \Fault \\
	\comp&\in \Comp
\end{align*}

Similar to \Fil programs, Safety Component Models have values of Boolean and integer type; we also have a domain of types
for those values.
\begin{align*}
    \bool \in \Bool &:= \{ \true, \false \}
    \\
    \integer \in \Integer &:= \{ \ldots, -2, -1, 0, 1, 2, \ldots \}
    \\
    \val \in \Val &:= \Bool \mid \Integer
    \\
	\type \in \Type &:= \boolType \mid \intType
\end{align*}

During execution, a \textit{variable environment} stores the values of all local variables as well as all input and output
parameters of a provided port.
A \textit{field environment} stores the values of all fields of all components in the hierarchy. Similarly, a \textit{fault
environment} is used to determine whether a component fault occurs. Since fields and faults are only unique within the context of
a single component, the field and fault environments need to know the the concrete component the field or fault is declared in.
A component is uniquely identified by the path through the component hierarchy starting at the root and proceeding down to the
component. We occasionally use field and fault environments in a curried form where the component path has already been provided.
\begin{align*}
	\varEnvFm \in \VarEnvFm &:= \Var \rightarrow \liftFailure{\Val} \\
	\fieldEnv \in \FieldEnv &:= \ToListNE{\Comp} \rightarrow \liftFailure{(\Field \rightarrow \liftFailure{\Val})} \\
	\fieldEnvCurried \in \FieldEnvCurried &:= \Field \rightarrow \liftFailure{\Val} \\
	\faultEnv \in \FaultEnv &:= \ToListNE{\Comp} \rightarrow \liftFailure{(\Fault \rightarrow \liftFailure{\Bool})} \\
	\faultEnvCurried \in \FaultEnvCurried &:= \Fault \rightarrow \liftFailure{\Bool}
\end{align*}

$\fieldEnvPrev$ and $\faultEnvPrev$ denote the field and fault environments at the end of the previous execution step.
$\varEnvFmEmpty$, $\fieldEnvEmpty$ and $\faultEnvEmpty$, on the other hand, denote the empty variable, field, and fault
environments, respectively.
We use the standard notation $\varEnvFm\left[\var \mapsto \val \right]$ to update the value of a variable $\var$ and also allow for simultaneous
updates, written as $\varEnvFm\left[\var_1, \ldots, \var_n \mapsto \val_1, \ldots, \val_n\right]$.
For field environments, the notation $\fieldEnv\left[\toListNE{\comp}, \field \mapsto \val \right]$ is used to update the value of
some field $\field$ within the hierarchy of components at location $\toListNE{\comp}$, where
\begin{equation*}
	\fieldEnv\left[\toListNE{\comp}, \field \mapsto \val \right](\toListNE{\comp}_0, \field_0) =
		\begin{cases}
			\val & \text{if } \toListNE{\comp} = \toListNE{\comp}_0 \wedge \field = \field_0 \\
			\fieldEnv(\toListNE{\comp}_0, \field_0) & \text{otherwise.}
		\end{cases}
\end{equation*}

We also allow for simultaneous updates of multiple fields of the same component, written as $\fieldEnv\left[\toListNE{\comp},
\field_1, \ldots, \field_n \mapsto \val_1, \ldots, \val_n \right]$ or $\fieldEnv\left[\toListNE{\comp}, \field_1, \ldots, \field_n
\mapsto \val \right]$ if all fields are updated to the same value. Similar notational conventions are used to update fault
environments.

\subsubsection{Expressions}
Formal models support only side effect free expressions. Expressions consist of literal values, read operations of variables
and fields as well as a small set of unary and binary operator applications.
\begin{align*}
	\uop \in \Uop & := \minusExprSym \mid \negateExprSym
	\\
    \bop \in \Bop & := \plusExprSym \mid \minusExprSym \mid \multExprSym \mid \divExprSym \mid \modExprSym
    				   \mid \lessExprSym \mid \greaterExprSym \mid \leqExprSym \mid \geqExprSym
    				   \mid \equalsExprSym \mid \notEqualsExprSym \mid \andExprSym \mid \orExprSym
	\\
	\expr \in \Expr & := 
		\val \mid
		\var \mid
		\field \mid 
		\unaryExpr{\uop\;}{\expr} \mid
		\binaryExpr{\;\bop\;}{\expr_1}{\expr_2}
\end{align*}

The function $\ExprSem{-} \colon \Expr \rightarrow \FieldEnvCurried \rightarrow \VarEnvFm \rightarrow \liftFailure{\Val}$ defines the
semantics of expressions. Since an expression of a non well-formed model might potentially access an undefined variable, the expression
evaluation might fail. 
\begin{align*}
	\ExprSem{\val} \fieldEnvCurried \varEnvFm &= \val \\
	\ExprSem{\var} \fieldEnvCurried \varEnvFm &= \varEnvFm(\var) \\
	\ExprSem{\field} \fieldEnvCurried \varEnvFm &= \fieldEnvCurried(\field) \\
	\ExprSem{\unaryExpr{\uop\;}{\expr}} \fieldEnvCurried \varEnvFm &= \llbracket \uop \rrbracket (\ExprSem{\expr} \fieldEnvCurried
	\varEnvFm) \\
	\ExprSem{\binaryExpr{\;\bop\;}{\expr_1}{\expr_2}} \fieldEnvCurried \varEnvFm &= \llbracket \bop \rrbracket
	(\ExprSem{\expr_1} \fieldEnvCurried \varEnvFm, \ExprSem{\expr_2} \fieldEnvCurried \varEnvFm)
\end{align*}

\subsubsection{Fault Expressions}
Fault expressions are used to select different overloads of component behaviors and provided ports, modeling the effects of
component faults on the behavior of the component itself or to zero, one, or more of its ports.
\begin{equation*}
	\faultExpr \in \FaultExpr := \fault \mid \negateExpr{\faultExpr} \mid
	\andExpr{\faultExpr_1}{\faultExpr_2}
	\mid \orExpr{\faultExpr_1}{\faultExpr_2}
\end{equation*}

The function $\FaultExprSem{-} \colon \FaultExpr \rightarrow \FaultEnvCurried \rightarrow \liftFailure{\Bool}$ defines the
semantics of fault expression. Since a fault expression of a non well-formed model might potentially access an undefined fault,
the expression evaluation might fail.
\begin{align*}
	\FaultExprSem{\fault} \faultEnvCurried &= \faultEnvCurried(\fault) \\
	\FaultExprSem{\negateExpr{\faultExpr}} \faultEnvCurried &= \neg \FaultExprSem{\faultExpr} \faultEnvCurried \\
	\FaultExprSem{\andExpr{\faultExpr_1}{\faultExpr_2}} \faultEnvCurried &= \FaultExprSem{\faultExpr_1} \faultEnvCurried \wedge
	\FaultExprSem{\faultExpr_2} \faultEnvCurried \\
	\FaultExprSem{\orExpr{\faultExpr_1}{\faultExpr_2}} \faultEnvCurried &= \FaultExprSem{\faultExpr_1} \faultEnvCurried \vee
	\FaultExprSem{\faultExpr_2} \faultEnvCurried
\end{align*}

\subsubsection{Statements}
An \Scm supports variable and field assignments, sequential composition, guarded commands,
invocations of required ports, as well as invocation of step behaviors of subcomponents and faults. Only variables but not fields
are allowed as output parameters of required port invocations. The expression on the right-hand side of an assignment to a fault
must be of type Boolean with a value evaluating to $\true$ indicating that the fault is currently occurring/active.
\begin{align*}
	\guardedCmd \in \GuardedCmd &:= \guardedClause{\expr}{\blockStm{\stmFm}} \\
	\stmFm \in \StmFm &:=
		\assignVarStm{\var}{\expr} \mid
		\assignVarStm{\field}{\expr} \mid
		\assignVarStm{\fault}{\expr} \mid
		\seqStm{\stmFm}{\toList{\stmFm}} \mid
		\\&\phantom{:= \;} \mid 
		\guardedStm{\toListNE{\guardedCmd}}
		\\&\phantom{:= \;} \mid
		\invokeReqPort{\reqPort}{\toList{\expr}}
		\\&\phantom{:= \;} \mid
		\stepStm{\comp} \mid \stepStm{\fault}
\end{align*}

\subsubsection{Variable and Field Declarations}
A variable declaration introduces typed local variables or parameters.
A field declaration declares component fields with a non-empty set of initial values, one of which is chosen
nondeterministically when the component hierarchy is initialized. Fields are global within the context of the component, but
cannot be accessed by parent components or subcomponents. Variables and parameters are only in scope within the context of a component behavior or
a provided port.
\begin{align*}
	\varDecl \in \VarDecl &:= \varDeclSyn{\var}{\type} \\
	\fieldDecl \in \FieldDecl &:= \fieldDeclSyn{\field}{\type}{\toListNE{\val}}
\end{align*}

We assume two functions $\varof \colon \VarDecl \rightarrow \Var$ and $\typeof \colon \VarDecl \rightarrow \Type$ with
$\varof(\varDeclSyn{\var}{\type}) = \var$ and $\typeof(\varDeclSyn{\var}{\type}) = \type$. Similarly for fields,
$\fieldof \colon \FieldDecl \rightarrow \Field$, $\typeof \colon \FieldDecl \rightarrow \Type$, and $\init \colon \FieldDecl \rightarrow
\ToSet{\Val}$ such that $\fieldof(\fieldDeclSyn{\field}{\type}{\toListNE{\val}}) = \field$,
$\typeof(\fieldDeclSyn{\field}{\type}{\toListNE{\val}}) = \type$, and
$\init(\fieldDeclSyn{\field}{\type}{\toListNE{\val}}) = \asSet(\toListNE{\val})$. We also use all of these functions
on lists of variable and field declarations, applying the function to each element of the list; for instance, $\varof(\varDecl_1
\cons \ldots \cons \varDecl_n) = \varof(\varDecl_1) \cons \ldots \cons \varof(\varDecl_n)$.

\subsubsection{Behaviors}
A behavior resembles a function body of a programming language such as C with all local variables declared at the beginning of the
function. All local variables of Safety Component Models are uninitialized by default. The effects of reading an
uninitialized value are undefined. A \CSharp-like check for definitive assignment could be performed to check for such a
situation; however, definite assignment is a complex property, requiring control flow analysis. If the safety component model is
generated from a \SafetySharp model, definitive assignment is already guaranteed by the \CSharp compiler.
\begin{equation*}
	\behavior \in \Behavior := \blockStm{\localsStm{\toList{\varDecl}} \; \stmFm}
\end{equation*}

The function $\locals \colon \behavior \rightarrow \ToList{\VarDecl}$ is used to select the local variables defined by a behavior:
$\locals(\blockStm{\localsStm{\toList{\varDecl}} \; \stmFm}) = \toList{\varDecl}$. To select the statement of a behavior, we use
the function $\stmof \colon \behavior \rightarrow \StmFm$ with $\stmof(\blockStm{\localsStm{\toList{\varDecl}} \; \stmFm}) =
\stmFm$.

By convention, the $\localsStm{}$ declaration can be omitted entirely if a behavior does not wish to declare any local variables.
Therefore, we consider the behaviors $\blockStm{\stmFm}$ and $\blockStm{\localsStm{\empty} \; \stmFm}$ to be equivalent.

\subsubsection{Required and Provided Ports}
A required port of a component has a possibly empty list of input and input/output parameters.
Provided ports are defined similarly. However, they also
declare a behavior in form of a statement, optionally also introducing additional local variables. A provided port is prefixed
with a fault expression; the fault expression is used to overload the provided port based on the component's current fault state.
Whenever a provided port is invoked, one of the overloads of the ports is chosen nondeterministically for which the fault
expression evaluates to $\true$. If no such overload exists, the default implementation is chosen. It is an error to define an
overloaded provided port without also defining the default implementation. 
\begin{align*}
	\parameterDecl \in \ParameterDecl &:=
		\varDecl \mid \inoutSyn{\varDecl}
	\\
	\reqPortDecl \in \ReqPortDecl &:=
		\reqPortDeclSyn{\reqPort}{\toList{\parameterDecl}}
	\\
	\provPortDecl \in \ProvPortDecl &:= \provPortDeclSyn{\provPort}
		{\toList{\parameterDecl}}
		{\behavior}
		{\liftMissing{\faultExpr}}
\end{align*}

If the fault expression is missing, the brackets can also be omitted and we consider the provided port declarations
$\provPortDeclSyn{\provPort} {\toList{\parameterDecl}}{\behavior}{\missing}$ and $\provPortDeclSynDefault{\provPort}{\toList{\parameterDecl}}{\behavior}$ to be
equivalent.
The parameter function $\isinout \colon \ParameterDecl \rightarrow \Bool$ returns $\true$ for an input/output parameter. We also
lift the $\varof$ and $\typeof$ functions to parameter declarations, selecting the variable declaration and the type of the
variable declaration of a parameter declaration, respectively.
The functions $\signature \colon \ReqPortDecl \rightarrow \ReqPort \times \ToList{\Type} \times \toList{\Bool}$ and $\signature
\colon \ProvPortDecl \rightarrow \ProvPort \times \ToList{\Type} \times \toList{\Bool}$ return the signature of a required or
provided port declaration, that is, the name of the port, the lists of the types of the parameters declared by the port, and for
each parameter a Boolean value indicating whether the parameter is an input/output parameter.
Therefore, $\signature(\reqPortDeclSyn{\reqPort}{\toList{\parameterDecl}}) = (\reqPort, \typeof(\toList{\parameterDecl}),
\isinout(\toList{\parameterDecl}))$ and
$\signature(\provPortDeclSyn{\provPort}{\toList{\parameterDecl}}{\behavior}{\liftMissing{\faultExpr}}) =
(\provPort, \typeof(\toList{\parameterDecl}),
\isinout(\toList{\parameterDecl}))$. The behavior declared by a provided port is
selected using the function $\behaviorof \colon \ProvPortDecl \rightarrow \Behavior$, defined as
$\behaviorof(\provPortDeclSyn{\provPort}{\toList{\parameterDecl}}{\behavior}{\liftMissing{\faultExpr}}) =
\behavior$. The potentially omitted fault expression of a provided port is selected by the function $\faultexprof \colon
\ProvPortDecl \rightarrow \liftMissing{\FaultExpr}$.

\subsubsection{Bindings}
A \textit{binding} binds a required port to a provided port. The binding must be either between two components on the
same level within the hierarchy or must span at most one level of the hierarchy. A binding can be either
\textit{instantaneous} or \textit{delayed}.

When a required port is invoked, the provided port bound to it is executed. Therefore, there must be exactly one binding for every
required port; on the other hand, there can be multiple or no bindings for provided ports. If the binding is instantaneous, the
bound provided port is executed using the current field environment. Delayed bindings, however, evaluate the provided port using
the state of the field environment at the end of the previous execution step. During a delayed computation, no required ports with
delayed bindings are allowed to be invoked. Also, the field environment is not allowed to change, therefore all assignments to
fields are illegal. Otherwise, it would be possible to ``rewrite history''.

Formally, a binding binds a \textit{binding source} to a \textit{binding target}; either instantaneously or delayed. A
binding source uniquely identifies a provided port of some component; the component must either be the component itself or one of
its direct subcomponents. Similarly, a binding target uniquely identifies a required port of the component itself or one of its
direct subcomponents.
\textit{\textbf{Todo: The components should be component paths.}}
\begin{align*} 
	\bindingType \in \BindingType &:=
		\instantBindingType \mid \delayedBindingType
	\\
	\bindingDecl \in \BindingDecl &:=
		\bindingDeclSyn{\qualifiedName{\comp}{\reqPort} }{\qualifiedName{\comp}{\provPort}}{\bindingType} 
\end{align*}

We define a substitution operation for components used within bindings as follows: Given a component $\comp$ that is to be
replaced by component $\comp'$, we update a binding source $\bindingSrc$ using the notation $\bindingSrc[\comp
\mapsto \comp']$, such that $(\provPort)[\comp \mapsto \comp'] = \provPort$ and $(\qualifiedName{\comp_1}{\provPort})[\comp
\mapsto \comp'] = \comp_2$ where $\comp_2 = \comp$ if $\comp \neq \comp'$ and $\comp_2 = \comp'$ otherwise. We define a
corresponding component substitution operation for binding targets as well. For bindings $\bindingDecl$, we then use the
notation $\bindingDecl[\comp \mapsto \comp']$, such that
$(\bindingDeclSyn{\bindingTarget}{\bindingSrc}{\bindingType})[\comp
\mapsto \comp'] = \bindingDeclSyn{\bindingTarget[\comp \mapsto \comp']}{\bindingSrc[\comp \mapsto \comp']}{\bindingType}$.
For a list of bindings $\toList{\bindingDecl}$, we use the notational convention
$\toList{\bindingDecl}[\comp \mapsto \comp']$ to substitute the component in all bindings contained in the list.

\subsubsection{Faults}
A \textit{fault} defines the the occurrence behavior of undesired or erroneous component behavior. Faults potentially affect
provided ports and component step behavior; the integration of such faults is guaranteed to be conservative in the sense that the
integration of faults into a model does not affect the behavior of the model if the faults do not occur. A fault can read and
write all of the declaring component's fields.
\begin{equation*}
	\faultDecl \in \FaultDecl := \faultDeclSyn{\fault}{\behavior}
\end{equation*} 

We assume two functions $\faultof \colon \FaultDecl \rightarrow \Fault$ and $\behaviorof \colon \FaultDecl \rightarrow \Behavior$
with $\faultof(\faultDeclSyn{\fault}{\behavior}) = \fault$ and $\behaviorof(\faultDeclSyn{\fault}{\behavior}) = \behavior$.

\subsubsection{Components}
A \textit{component} declares sets of required and provided ports, fields, faults, port bindings, and subcomponents. They have a
step behavior with optional local variables. Similar to provided ports, the step behavior can be overloaded for different fault
situations.
\begin{align*}
	\stepDecl \in \StepDecl &:= \stepDeclSyn{\behavior}{\liftMissing{\faultExpr}}
	\\
	\compDecl \in \CompDecl &:=  
		\compDeclSyn{\comp}
			{\toList{\compDecl}}
			{\toList{\fieldDecl}}
			{\toList{\faultDecl}}
			{\toList{\reqPortDecl}}{\toList{\provPortDecl}}
			{\toList{\bindingDecl}}
			{\toList{\stepDecl}}
\end{align*}

We define a couple of selector methods: $\compof \colon \CompDecl \rightarrow \Comp$ yields the component declared by the
component declaration, whereas the functions $\reqsof \colon \CompDecl \rightarrow \ToSet{\ReqPortDecl}$ and $\provsof \colon
\CompDecl \rightarrow \ToSet{\ProvPortDecl}$ return the declared required and provided ports, respectively. $\subsof \colon \CompDecl \rightarrow
\ToSet{\CompDecl}$ returns the set of subcomponent declarations of a component declaration.


We use the $\in$ operator to check whether a component declaration declares a specific subcomponent, required or provided port,
field, or binding.
For instance, for required port declarations we have
$\reqPortDeclSyn{\reqPort}{\toList{\type_\mathit{in}}}{\toList{\type_\mathit{io}}} \in
(\compDeclSyn{\comp}{\toList{\compDecl}}{\toList{\fieldDecl}}{\toList{\reqPortDecl}}{\toList{\provPortDecl}}{\toList{\bindingDecl}}{\behavior})
\Leftrightarrow \reqPortDeclSyn{\reqPort}{\toList{\type_\mathit{in}}}{\toList{\type_\mathit{io}}} \in \toList{\reqPortDecl}$.

We are allowed to substitute a subcomponent declaration of some component declaration, provided that the original subcomponent
declaration $\compDecl'$ and the new subcomponent declaration $\compDecl''$ are port-equivalent, that is
$\signature(\reqsof(\compDecl')) = \signature(\reqsof(\compDecl''))$ and $\signature(\provsof(\compDecl')) =
\signature(\provsof(\compDecl''))$.
We use the notation $\compDecl[\compDecl' \mapsto \compDecl'']$ to obtain a new component declaration where $\compDecl'$ has been
replaced with $\compDecl''$. Consequently,
$(\compDeclSyn{\comp}{\toList{\compDecl}}{\toList{\fieldDecl}}{\toList{\faultDecl}}{\toList{\reqPortDecl}}{\toList{\provPortDecl}}{\toList{\bindingDecl}}{\behavior})[\compDecl'
\mapsto \compDecl''] = \compDeclSyn{\comp}{\toList{\compDecl}[\compDecl' \mapsto
\compDecl'']}{\toList{\fieldDecl}}{\toList{\faultDecl}}{\toList{\reqPortDecl}}{\toList{\provPortDecl}}{\toList{\bindingDecl}[\compDecl'
\mapsto \compDecl'']}{\behavior[\compDecl'\mapsto \compDecl'']}$. We also allow for simultaneous substitution of multiple subcomponents, written
as $\compDecl[\compDecl_1, \ldots, \compDecl_n \mapsto \compDecl_1', \ldots, \compDecl_n']$. On the other hand, we have
$\compDecl[\compDecl' \mapsto \compDecl''] = \compDecl''$ if $\compDecl = \compDecl'$.

We can also select a subcomponent declaration at some level of the component hierarchy using the subcomponent selector $.[.]
\colon \CompDecl \times \ToListNE{\Comp} \rightarrow \liftFailure{\CompDecl}$, defined as
\begin{align*}
	\compDecl[\comp] &= \begin{cases}
		\compDecl & \text{if } \compof(\compDecl) = \comp \\
		\failure & \text{otherwise}
	\end{cases} \\
	\compDecl[\comp_1 \cons \comp_2 \cons \toList{\comp}] &= 
		\begin{cases}
			\compDecl'[\comp_2 \cons \toList{\comp}] & \text{if } 
				\compof(\compDecl) = \comp_1 \wedge \exists \compDecl' \in \compDecl \colon \compof(\compDecl') = \comp_2 \\
			\failure & \text{otherwise.}
		\end{cases}
\end{align*}

\subsection{Well-Formedness of Components}
We only consider components that are well-formed according to the following criteria:
\begin{itemize}
	\item To decide: Should we restrict calls to subcomponent behaviors to exactly one invocation per step?
	\item All expressions and statements are typed correctly.
	\item All fields, required ports, and provided ports within a component have a unique name.
	\item All subcomponents of a component have unique names.
	\item All statements and expressions respect the scoping of parameters, locals, fields, and required ports.
	\item All bindings respect the component hierarchy: A binding connecting two ports of components $\comp_1$ and $\comp_2$ within
	the context of component $\comp$ with subcomponents $\toSet{s}$ is only well-formed if $\comp_1, \comp_2 \in \{ \comp \} \cup
	\toSet{s}$.
	\item There are no circular bindings, resulting in a provided port indirectly invoking itself. Such a circle can only be allowed
	if at least one of the involved bindings is delayed.
	\item There is exactly one binding for each required port; there can be none, one, or multiple bindings for a provided port.
	\item A binding source or target within a component $\comp$ may reference $\comp$ if and only if $\comp$ has a subcomponent also
	named $\comp$.
	\item The ports of a binding are compatible, that is, they have the same signature (= type, order, and number of input and
	output parameters).
	\item A provided port can only be part of a delayed binding if it does not assign to any fields. This requirement is transitive,
	meaning that all ports called by such a provided port are also not allowed to write to fields.
	\item A provided port can only be part of a delayed binding if it does not invoke any required ports with a delayed binding. This
	requirement is transitive, meaning that all ports called by such a provided port are also not allowed invoke required ports with
	a delayed binding.
	\item Required ports are invoked with the correct parameters (both in type and number).
	\item All ports mentioned in a binding are actually declared in the respective component.
	\item All invoked required ports are actually declared in the component.
	\item All local variables must be definitely assigned before they are first read. Analogous to \CSharp's definite assignment.
	Definite assignment is somewhat complex to check, requiring a control flow analysis. If an unassigned variable is read, the
	semantics would just ``hang``, so we could just live with that without making definite assignment a well-formedness requirement.
	Particularly, when transforming a \SSharp model into a formal model, definite assignment is guaranteed by the \CSharp compiler
	anyway. However, the purpose of the well-formedness property is to guarantee that the resulting \Fil program
	has infinite traces only. If we don't require definite assignment, infinite traces cannot be guaranteed. Note that parameters
	of a required port are always definitely assigned (it is illegal to call a required port without the correct number and type of
	parameters) and fields always have at least one initial value, so they're also always definitely assigned. Therefore, the easiest thing to do might be to require explicit initial values for
	local variable declarations.
	\item Note that we do not have to check for component cycles (i.e., a component being its own parent), as that simply cannot be
	expressed with the domains we have defined.
	\item All faults of a component have unique names.
	\item All faults within a component have unique names; their names do not overlap with any names of the component.
	\item Assignments to faults only occur within the fault itself.
	\item If there is a provided port or step method with a fault attribute, there must also be a declaration of the provided port or
	step method without a fault attribute (or a fault attribute with expression $\trueExpr$).
\end{itemize}

\subsection{Semantics of Formal Models}
The nondeterministic rule system $\stmArrowFm$ is parametrized over a component declaration or hierarchy $\compDecl$. It defines
the natural semantics of Safety Component Model statements.
\begin{align*}
	\mathit{Configurations} \colon & \;\configurationFm{\stmFm, \fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}} \in \StmFm
	\times \FieldEnv \times \FaultEnv \times \VarEnvFm \times \ToListNE{\Comp},
	\\
	& \; \configurationFm{\fieldEnv, \faultEnv, \varEnvFm} \in \FieldEnv \times \FaultEnv \times \VarEnvFm
	\\
	\mathit{Transitions} \colon & \;\configurationFm{\stmFm, \fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}} \stmArrowFm
	\configurationFm{\fieldEnv', \faultEnv', \varEnvFm'}
\end{align*}

Assignments to a variable update the variable environment accordingly, replacing the variable's current value with the value
obtained from the evaluation of the assigned expression.
\begin{equation*}
	\tag{assign${}_\text{v}$}
	\configurationFm{\assignVarStm{\var}{\expr}, \fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}}
		\stmArrowFm
	\configurationFm{\fieldEnv, \varEnvFm[\var \mapsto \ExprSem{\expr} \fieldEnv(\toListNE{\comp}) \varEnvFm]}
\end{equation*}

Assignments to a field update the field environment accordingly, replacing the fields current value with the value
obtained from the evaluation of the assigned expression.
\begin{equation*}
	\tag{assign${}_\text{f}$}
	\configurationFm{\assignVarStm{\field}{\expr}, \fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}}
		\stmArrowFm
	\configurationFm{\fieldEnv[\toListNE{\comp}, \field \mapsto \ExprSem{\expr} \fieldEnv(\toListNE{\comp}) \varEnvFm], \varEnvFm}
\end{equation*}

Sequential composition executes all statements sequentially, carrying along the modified variable, field, and fault environments.
If the statement list is empty, no changes are made to those environments.
\begin{equation*}
	\tag{seq}
	\dfrac
	{
		\configurationFm{\stmFm_1, \fieldEnv_0, \faultEnv_0, \varEnvFm_0, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv_1, \faultEnv_1, \varEnvFm_1}
		\;
		\ldots
		\;
		\configurationFm{\stmFm_n, \fieldEnv_{n-1}, \faultEnv_{n-1}, \varEnvFm_{n-1}, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv_n, \faultEnv_n, \varEnvFm_n}
	}
	{
		\configurationFm{\stmFm_1 \ldots \stmFm_n, \fieldEnv_0, \faultEnv_0, \varEnvFm_0, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv_n, \faultEnv_n, \varEnvFm_n}
	}
\end{equation*}

Guarded commands nondeterministically choose and execute a statement whose corresponding guard evaluates to true. If no guard
evaluates to true, the rule cannot be applied and hence the program is ``stuck''.
\begin{equation*}
	\tag{choice}
	\dfrac
	{
		\configurationFm{\stmFm_i, \fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv', \faultEnv', \varEnvFm'}
	}
	{
		\configurationFm{\guardedStm{\guardedClause{\expr_1}{\stmFm_1} \; \ldots \; \guardedClause{\expr_n}{\stmFm_n}}, \fieldEnv,
		\faultEnv, \varEnvFm,
		\toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv', \faultEnv', \varEnvFm'}
	}
	\qquad \text{if} \quad \ExprSem{e_i} \fieldEnv(\toListNE{\comp}) \varEnvFm = \true
\end{equation*}

We define a helper function $\copyout \colon \FieldEnv \times \FaultEnv \times \VarEnvFm \times 
\toListNE{\Comp} \times \toList{\Val} \times \toList{\Bool} \times \toList{\Expr} \rightarrow \liftFailure{(\FieldEnv \times
\FaultEnv \times \VarEnvFm)}$ that copies the values of the input/output parameters of a port invocation to the field or variable environments, depending on the expression that was used to
invoke the port. This function fails when a non ``l-value'' expression was passed to an
input/output parameter or the lengths of the different lists do not match, etc.
\begin{align*}
	\copyout(\fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}, \missing, \missing, \missing) &= (\fieldEnv, \faultEnv,
	\varEnvFm)
	\\
	\copyout(\fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}, \val \cons \toList{\val}, \false \cons
	\toList{\mathit{io}}, \expr \cons \toList{\expr}) &= \copyout(\fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp},
	\toList{\val}, \toList{\mathit{io}}, \toList{\expr})
	\\
	\copyout(\fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}, \val \cons \toList{\val}, \true \cons
	\toList{\mathit{io}}, \var \cons \toList{\expr}) &= \copyout(\fieldEnv, \faultEnv, \varEnvFm[\var \mapsto \val],
	\toListNE{\comp}, \toList{\val}, \toList{\mathit{io}}, \toList{\expr})
	\\
	\copyout(\fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}, \val \cons \toList{\val}, \true \cons
	\toList{\mathit{io}}, \field \cons \toList{\expr}) &= \copyout(\fieldEnv[\toListNE{\comp}, \field \mapsto \val],
	\faultEnv, \varEnvFm, \toListNE{\comp}, \toList{\val}, \toList{\mathit{io}}, \toList{\expr})
\end{align*}

We also define a helper function $\boundof_{\compDecl, \bindingType} \colon \ToListNE{\Comp} \rightarrow \ReqPort
\rightarrow \liftFailure{(\ToListNE{\Comp} \times \ProvPort)}$ that is parametrized over a component hierarchy $\compDecl$ and a
binding kind $\bindingType$. It returns the provided port bound to a required port as follows:
\begin{align*}
	\boundof_{\compDecl, \bindingType}(\toList{\comp} \cons \comp, \reqPort) &=
		\begin{cases}
			(\toList{\comp} \cons \comp, \provPort) & \; \, \text{if }
				\bindingDeclSyn{\reqPort}{\provPort}{\bindingType} \in
				\compDecl[\toList{\comp} \cons \comp] \\
			(\toList{\comp} \cons \comp \cons \comp', \provPort) & \; \, \text{if }
				\bindingDeclSyn{\reqPort}{\qualifiedName{\comp'}{\provPort}}{\bindingType} \in
				\compDecl[\toList{\comp} \cons \comp]
		\end{cases} \\
	\boundof_{\compDecl, \bindingType}(\toList{\comp} \cons \comp_1 \cons \comp_2, \reqPort) &=
		\begin{cases}
			(\toList{\comp} \cons \comp_1, \provPort) & \text{if }
				\bindingDeclSyn{\qualifiedName{\comp_2}{\reqPort}}{\provPort}{\bindingType} \in
				\compDecl[\toList{\comp} \cons \comp_1] \\
			(\toList{\comp} \cons \comp_1 \cons \comp', \provPort) & \text{if }
				\bindingDeclSyn{\qualifiedName{\comp_2}{\reqPort}}{\qualifiedName{\comp'}{\provPort}}{\bindingType} \in
				\compDecl[\toList{\comp} \cons \comp_1]
		\end{cases}
\end{align*}

An additional helper function is $\select \colon \CompDecl \times \FaultEnvCurried \times \ProvPort \rightarrow
\liftFailure{\ProvPortDecl}$. It returns a provided port to call by choosing one of the port's overloads for which the fault
expression holds nondeterministically. If no such overload exists, the port's default implementation is returned.
\begin{equation*}
	\select(\compDecl, \faultEnvCurried, \provPort) =
	\begin{cases}
		(\provPortDeclSyn{\provPort}{\toList{\parameterDecl}}{\behavior}{\faultExpr}) \in \compDecl & \text{if } \FaultExprSem{\faultExpr} \faultEnvCurried
		\\
		\provPortDeclSyn{\provPort}{\toList{\parameterDecl}}{\behavior}{\missing} \in \compDecl & \text{otherwise}
	\end{cases} 
\end{equation*}

When a required port is called that is instantaneously bound to a provided port, we execute the bound port's statement.
While the field environment remains unchanged, the component context might change and the port is executed in a new, empty
variable environment in which only the values of the port's parameters are set; the values of the port's local variables remain undefined. Once we're
done with the execution of the port, we restore our previous variable environment, taking over the port's output values as well
as the updated field and fault environments. Depending on the faults currently active within the provided port's
declaring component, the port's default implementation or one of its overloads are invoked.
\begin{multline*}
	\tag{call${_i}$}
	\dfrac
	{
		\configurationFm{\stmof({\behavior}), \fieldEnv, \faultEnv, \varEnvFmEmpty[\varof(\toList{\parameterDecl}) \mapsto
		\ExprSem{\toList{\expr}}\fieldEnv(\toListNE{\comp})\varEnvFm],
		\toListNE{\comp}_\provPort}
			\stmArrowFm
		\configurationFm{\fieldEnv', \faultEnv', \varEnvFm'}
	}
	{
		\configurationFm{\invokeReqPort{\reqPort}{\toList{\expr}}, \fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}}
			\stmArrowFm
		\copyout(\fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp},
		\varEnvFm'(\varof(\toList{\parameterDecl})), \isinout(\toList{\parameterDecl}), \toList{\expr}) 
	}
	\\ \text{if} \quad \boundof_{\compDecl, \instantBindingType}(\toListNE{\comp},
	\reqPort) = (\toListNE{\comp}_\provPort, \provPort) \wedge
	\select(\compDecl[\toListNE{\comp}_\provPort], \faultEnv(\toListNE{\comp}_\provPort),
	\provPort) = (\provPortDeclSyn{\provPort}{\toList{\parameterDecl}}{\behavior}{\liftMissing{\faultExpr}})
\end{multline*}

When a required port with a delayed binding to a provided port is called, we execute the bound port's statement in the context of
the \textit{previous} field and fault environments. The component context might change and the port is executed in a new, empty
variable environment in which only the values of the port's parameters are set; the values of the port's local variables remain undefined. Once we're
done with the execution of the port, we restore the field, fault, and variable environments we started with, only
taking over the port's output values. Note that the rule requires that the execution of the provided port does not change the
field and fault environments; if it does, the rule cannot be applied and execution is ``stuck''. Depending on the faults that have
been active at the end of the previous step in the provided port's declaring component, the port's default
implementation or one of its overloads are invoked.
\begin{multline*}
	\tag{call${_d}$}
	\dfrac
	{
		\configurationFm{\stmof({\behavior}), \fieldEnvPrev, \faultEnvPrev, \varEnvFmEmpty[\varof(\toList{\parameterDecl}) \mapsto
		\ExprSem{\toList{\expr}}\fieldEnv(\toListNE{\comp})\varEnvFm],
		\toListNE{\comp}_\provPort}
			\stmArrowFm
		\configurationFm{\fieldEnvPrev, \faultEnvPrev, \varEnvFm'}
	}
	{
		\configurationFm{\invokeReqPort{\reqPort}{\toList{\expr}}, \fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}}
			\stmArrowFm
		\copyout(\fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp},
		\varEnvFm'(\varof(\toList{\parameterDecl})), \isinout(\toList{\parameterDecl}), \toList{\expr})
	}
	\\ \text{if} \quad \boundof_{\compDecl, \delayedBindingType}(\toListNE{\comp},
	\reqPort) = (\toListNE{\comp}_\provPort, \provPort) \wedge
	\select(\compDecl[\toListNE{\comp}_\provPort], \faultEnvPrev(\toListNE{\comp}_\provPort),
	\provPort) = (\provPortDeclSyn{\provPort}{\toList{\parameterDecl}}{\behavior}{\liftMissing{\faultExpr}})
\end{multline*}

The helper function $\selectStep \colon \CompDecl \times \FaultEnvCurried \rightarrow
\liftFailure{(\StmFm)}$ returns the statements of a step behavior depending on the component's current fault state. Analogous to
how provided ports are selected, one of the component step behavior's overloads is chosen nondeterministically for which the fault
expression holds. If no such overload exists, the step behavior's default implementation is returned.
\begin{equation*}
	\selectStep(\compDecl, \faultEnvCurried) =
	\begin{cases}
		\stepDeclSyn{\behavior}{\faultExpr} \in \compDecl & \text{if } \FaultExprSem{\faultExpr} \faultEnvCurried
		\\
		\stepDeclSyn{\behavior}{\missing} \in \compDecl & \text{otherwise}
	\end{cases} 
\end{equation*}

When the step behavior of a subcomponent is invoked, the subcomponent is added to the component path and an empty variable
environment is used to execute the behavior. Execution of the current behavior or port continues with the new field and fault environments and
the old variable environment. Depending on the faults currently active within the subcomponent, the component's default step
behavior or one of its overloads are invoked.
\begin{equation*}
	\tag{step$_{\comp}$}
	\dfrac
	{
		\configurationFm{\stmFm, \fieldEnv, \faultEnv, \varEnvFmEmpty, \toListNE{\comp}
		\cons \comp}
			\stmArrowFm
		\configurationFm{\fieldEnv', \faultEnv', \varEnvFm'}
	}
	{
		\configurationFm{\stepStm{\comp}, \fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv', \faultEnv', \varEnvFm}
	}
	\qquad \text{if} \quad
	\selectStep(\compDecl[\toListNE{\comp}], \faultEnv(\toListNE{\comp} \cons \comp)) = \stmFm 
\end{equation*}

When the step behavior of a fault is invoked, execution is transferred directly to the fault's step behavior as the step behavior
of a fault cannot be overloaded.
\begin{equation*}
	\tag{step$_{\fault}$}
	\dfrac
	{
		\configurationFm{\stmof(\behavior), \fieldEnv, \faultEnv, \varEnvFmEmpty, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv', \faultEnv', \varEnvFm'}
	}
	{
		\configurationFm{\stepStm{\fault}, \fieldEnv, \faultEnv, \varEnvFm, \toListNE{\comp}}
			\stmArrowFm
		\configurationFm{\fieldEnv', \faultEnv', \varEnvFm}
	}
	\qquad \text{if} \quad
	\faultDeclSyn{\fault}{\behavior} \in \compDecl[\toListNE{\comp}] 
\end{equation*}

% \begin{equation*}
% 	\tag{call${}_2$}
% 	\dfrac
% 	{
% 		\configuration{\stmof(\behavior((\comp.\compName).\provPortName)), \varEnvFmScoped, \toList{\comp} \cons \comp \cons
% 		\comp.\compName}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	{
% 		\configuration{\invoke{\reqPortName}{\toList{\expr}}{\toList{\varName}}, \varEnvFmScoped, \toList{\comp} \cons \comp}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	\quad \text{if } \bindings(\comp)[\comp, \reqPortName] = (\compName, \provPortName) \wedge \compName \neq \nameof(\comp)
% \end{equation*}
% 
% \begin{equation*}
% 	\tag{call${}_3$}
% 	\dfrac
% 	{
% 		\configuration{\stmof(\behavior(\comp.\provPortName)), \varEnvFmScoped, \toList{\comp} \cons \comp}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	{
% 		\configuration{\invoke{\reqPortName}{\toList{\expr}}{\toList{\varName}}, \varEnvFmScoped, \toList{\comp} \cons \comp \cons
% 		\comp'}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	\quad \text{if } \bindings(\comp)[\comp', \reqPortName] = (\nameof(\comp), \provPortName)
% \end{equation*}
% 
% \begin{equation*}
% 	\tag{call${}_4$}
% 	\dfrac
% 	{
% 		\configuration{\stmof(\behavior((\comp.\compName).\provPortName)), \varEnvFmScoped, \toList{\comp} \cons \comp \cons
% 		\comp.\compName}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	{
% 		\configuration{\invoke{\reqPortName}{\toList{\expr}}{\toList{\varName}}, \varEnvFmScoped, \toList{\comp} \cons \comp \cons
% 		\comp'}
% 			\stmArrowFm
% 		\varEnvFmScoped'
% 	}
% 	\quad \text{if } \bindings(\comp)[\comp', \reqPortName] = (\compName, \provPortName) \wedge \compName \neq \nameof(\comp)
% \end{equation*}

\subsection{Transformation to \Fil Programs}
The transformation of a well-formed formal model into a \Fil program first flattens the hierarchy in post order. That is, for a
given component, all fields, ports, and bindings are moved to the parent component, ensuring that all names remain unique. The behavior
is added at the correct location into the parent's behavior, depending on the scheduling. 

Once the hierarchy is fully flattened, all ports are inlined into the behavior of the root component. For delayed bindings, the
appropriate variables must be introduced. When the results of a delayed binding are read, the \texttt{prev} instruction must be used.

The resulting monolithic component can then be transformed in a rather straightforward way to a \Fil program.

\section{Modeling with \SafetySharp}
The general idea of the transformation process is as follows:
\begin{itemize}
	\item Compile-time
	\begin{enumerate}
		\item If the \SSharp model is not valid \CSharp code, abort.
		\item \SSharp well-formedness checks are performed. If the model is not well-formed, abort.
		\item Perform \CSharp code normalizations.
		\item For each component type in the \SSharp model, create a builder that -- at runtime -- creates a formal
		model component instance for a concrete \SSharp component instance of the component type, recursively also transforming the
		entire component subtree in post order. 
		
		For generic component types, these builders are also generic, causing the generics to be resolved by standard \DotNet
		mechanisms.
	\end{enumerate}
	
	\item Runtime
	\begin{enumerate}
		\item Initialize the component instances, running their constructors. Abort if any exceptions occur.
		\item Perform runtime well-formedness checks. Abort if the model is not well-formed.
		\item Determine the array sizes for all fields, locals and parameters of the model. Abort if there is an array for which no
		unique array size can be determined.
		\item Additional pass-through ports and the appropriate bindings must be introduced if the component has subcomponents with ports
		bound to ports of components of another partition.
		\item Synthesize a unique root component for the entire component hierarchy.
		\item Invoke the builder for the main component instance in the hierarchy tree, causing the transformation of the tree in post
		order. The result is a formal model. It is well-formed if no components defined in an external assembly are used. Otherwise, the
		formal model is only well-formed if the external assembly is not ``malicious''.
	\end{enumerate}
\end{itemize}

\subsection{Runtime Well-Formedness Checks}
Certain well-formedness checks on the \SSharp model cannot be performed at compile time, as runtime information is required:
\begin{itemize}
	\item Every component appears only once in the hierarchy (no shared components).
	\item Port bindings can optionally be checked, but this is part of the formal model well-formedness check anyway, so it can be
	skipped here.
	\begin{itemize} 
		\item Port bindings cannot be circular, unless at least one delayed binding is involved.
		\item Port bindings cannot span more than one level of the component hierarchy and cannot cross different branches of the tree,
		expect for bindings crossing partition boundaries.
		\item Every required port can only be contained in exactly one binding.
	\end{itemize}
	\item Port bindings are only allowed between compatible component types, i.e., it is invalid to bind a required port of a
	controller component to a provided port of an environment component. Note that signature compatibility is enforced by the \CSharp
	compiler.
	\item It must be possible to uniquely determine the sizes of all arrays used throughout the component hierarchy (either as local
	variables, port parameters, or fields). 
\end{itemize}

\subsection{Transformation to Formal Models}
All \SSharp models are valid \CSharp code. At compile time, additional \SSharp-specific checks are made on the
\CSharp code that guarantee that the code can be successfully transformed and that the transformed formal model is well-formed.
Even if the \CSharp code is error-free, the generated formal model must be checked for well-formedness, especially when components
from external \SSharp assemblies are used.

Certain \CSharp features that can be used when writing \SSharp models are normalized to other, semantically equivalent
\CSharp features, in order to reduce the complexity of the transformation to formal models. Component initialization and
construction use standard \CSharp/\DotNet mechanisms.

The following normalization are performed on the \CSharp code. The resulting (still valid) \CSharp code should be straightforward
to transform into a formal model.
\begin{itemize}
	\item State machines must be transformed to equivalent imperative code.
	\item Implementation inheritance is flattened. 
	\item Properties and indexers are replaced with the appropriate getter or setter methods.
	\item Variables of enum type are replaced by \texttt{int}, enum values are replaced by their underlying integer value.
	\item Compound assignment operators (\texttt{+=}, \texttt{-=}, etc.) are replaced by the appropriate expression and a simple
	assignment.
	\item Chained assignments must be split into several ones.
	\item Multiple local variables declared by the same declaration are split into multiple declarations.
	\item All locally declared variables that are not initialized during declaration are initialized to their default value.
	\item Additional required ports must be introduced for all provided ports of subcomponents invoked by the parent component. The
	corresponding provided port invocations have to be replaced by the synthesized required ports and the corresponding bindings have
	to be established.
	\item All methods calls (both helper methods and invocations of other provided ports of the same component) must be inlined. The
	only invocations allowed to remain are invocations of required ports.
	\item All ports are rewritten such that they have a \texttt{void} return type, with the returned values written to newly
	introduced \texttt{ref} parameters. All invocations are normalized accordingly.
	\item If a port contains \texttt{out} parameters, the \texttt{out} keyword is replaced with \texttt{ref}.
	\item If a port contains \texttt{ref} parameters, all of those parameters are moved to the end of the method signature.
	\item All invocations that have fields as \texttt{ref} parameters are rewritten such that for all field \texttt{ref} parameters new variables are
	introduced that are used as the \texttt{ref} parameters instead of the fields. After the invocation, the values of these
	variables are assigned to the corresponding field.
	\item Named parameters are sorted in accordance with the parameter declarations; optional parameters are filled in.
	\item Expressions must be rewritten such that they contain no side effects (assignments to variables, method calls, overloaded
	operators).
	\item Fields, local variables, properties, indexers and parameters of struct or array type must be replaced by the appropriate
	number of flattened elements. Structs and arrays can be recursive in the sense that a struct can contain an array of structs,
	and so on. Structs can be replaced at compile time. Arrays cannot be replaced at compile time, as the size of an array can
	generally only be determined at run-time when the port bindings have been established. It is an error if no unique size can be
	determined. Code accessing array or struct elements must be rewritten accordingly. Operations on arrays (Linq-like functions or
	\texttt{foreach} loops) must be unrolled. For arrays, the builders generate the appropriate instructions dynamically at runtime
	based on the determined array size.
	\item Component scheduling: By default, all subcomponents of a component are scheduled at the beginning of the parent component's
	\texttt{Update} method in some fixed but undefined order. The \texttt{Schedule} function can be used in the
	constructor of the parent component to define an explicit schedule.
	The call to \texttt{Schedule} must be exhaustive and it must also include the parent component itself. 
	If a component's \texttt{Update} method is called explicitly by the parent component's \texttt{Update} method, it is not allowed in a call to \texttt{Schedule} and it is never
	scheduled automatically by the system.
	An inherited component must call the base \texttt{Update} at some time in its \texttt{Update} function, if it decides to override
	\texttt{Update}. Multiple calls to \texttt{Schedule} are allowed so that inherited components can use \texttt{Schedule} to
	explicitly define the scheduling of their subcomponents in addition to the base component's call to \texttt{Schedule}; inherited
	components can for instance schedule their subcomponents in-between two subcomponents of the base component, provided that the
	base component exposes its subcomponents to its derived types (via the \texttt{protected} visibility modifier, for instance). If
	different calls to \texttt{Schedule} contradict each other, an error is raised at runtime. Root components are scheduled in the
	order they're added to the model.
\end{itemize}

\end{document}
